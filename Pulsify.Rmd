---
title: "Pulsify: Spotify Track Recommendation System"
author: "Selim Erenay, Omer Erenay"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(readr)
library(dplyr)
library(ggplot2)
library(proxy)
```

# Introduction

This project builds a **content-based song recommendation system** using Spotify track data.  
We use audio features such as `danceability`, `energy`, `valence`, `tempo`, and `acousticness` to find songs that are musically similar to a selected track.

# Data Loading

```{r}
# Load dataset
data <- read_csv("dataset.csv")

# Quick overview
glimpse(data)
summary(data)
```

# Data Preprocessing

We selected relevant audio features and normalized them to ensure fair comparisons.

```{r}
# Selecting important features
features <- data %>%
  select(track_name, artists, danceability, energy, valence, tempo, acousticness) %>%
  na.omit()

# Normalizing numerical features
features_normalized <- features %>%
  mutate(across(c(danceability, energy, valence, tempo, acousticness),
                ~ scale(.)[,1]))
```

# Building the Recommendation System

We created a function `recommend_track()` that:
- Selects the most popular version of a track
- Compares all songs to it using **Euclidean distance**
- Returns the top 10 most similar songs
- Plots the results
- Saves recommendations automatically to a CSV file

```{r}
recommend_track <- function(song_title) {
  most_popular_row <- data %>%
    filter(track_name == song_title) %>%
    arrange(desc(popularity)) %>%
    slice(1)

  reference <- features_normalized %>%
    filter(track_name == most_popular_row$track_name,
           artists == most_popular_row$artists) %>%
    select(danceability, energy, valence, tempo, acousticness) %>%
    slice(1)

  comparison_data <- features_normalized %>%
    select(danceability, energy, valence, tempo, acousticness)

  distances <- proxy::dist(comparison_data, reference, method = "euclidean")

  features_with_distance <- features_normalized %>%
    mutate(distance = as.vector(distances))

  recommendations <- features_with_distance %>%
    filter(track_name != most_popular_row$track_name | artists != most_popular_row$artists) %>%
    arrange(distance) %>%
    distinct(track_name, artists, .keep_all = TRUE) %>%
    select(track_name, artists, distance) %>%
    slice(1:10)

  # Plot
  plot <- ggplot(recommendations, aes(x = reorder(track_name, -distance), y = distance)) +
    geom_col(fill = "steelblue") +
    coord_flip() +
    labs(title = paste("Top 10 Songs Similar to", song_title),
         x = "Track Name", y = "Distance")

  print(plot)

  # Export CSV
  filename <- paste0(gsub(" ", "_", tolower(song_title)), "_recommendations.csv")
  write_csv(recommendations, filename)

  return(recommendations)
}
```

# Running the Recommendation System

Example: finding songs similar to **"Blinding Lights"**.

```{r}
recommend_track("Blinding Lights")
```
# Conclusion

Using normalized audio features and Euclidean distance, we successfully built a content-based recommendation engine.  
This system recommends the top 10 most similar songs to any chosen track and saves results for further analysis.

After each function call, the top 10 recommended songs are automatically exported into a CSV file, named based on the selected track (e.g., `blinding_lights_recommendations.csv`).
This allows for easy retrieval and sharing of recommendation results.



